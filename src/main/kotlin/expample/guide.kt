package expample

////Функция для преобразования градусов в радианы
//import kotlin.math.*
//
//fun toRadians(degrees: Double): Double {
//    return degrees * Math.PI / 180
//}
//
//fun main() {
//    // Константы
//    val g = 9.8 // ускорение свободного падения, м/с^2100
//
//    // Ввод данных пользователем
//    print("Введите высоту обрыва (H): ")
//    val H = readLine()?.toDoubleOrNull() ?: return
//
//    print("Введите начальную скорость (V): ")
//    val V = readLine()?.toDoubleOrNull() ?: return
//
//    print("Введите угол броска (α) в градусах: ")
//    val alpha = readLine()?.toDoubleOrNull() ?: return
//
//    print("Введите время (t): ")
//    val t = readLine()?.toDoubleOrNull() ?: return
//
//    // Преобразование угла в радианы
//    val alphaRad = toRadians(alpha)
//
//    // Вычисление координаты x(t) - расстояние до края обрыва
//    val x = V * t * cos(alphaRad)
//
//    // Вычисление координаты y(t) - высота от дна обрыва
//    val y = H + V * t * sin(alphaRad) - g * t * t / 2
//
//    // Проверка, упал ли камень на дно обрыва
//    val yFinal = if (y < 0) 0.0 else y
//
//    val roundedX = String.format("%.2f" , x)
//    val roundedY = String.format("%.2f" , yFinal)
//
//
//    // Вывод результатов
//    println("Положение камня в момент времени t = $t:")
//    println("Расстояние до края обрыва x(t): $roundedX м")
//    println("Высота от дна обрыва y(t): $roundedY м")
//
//    // Вычисление времени полета (время, когда камень достигнет дна)
//    val T = (V * sin(alphaRad) + sqrt(V * V * sin(alphaRad) * sin(alphaRad) + 2 * g * H)) / g
//    val roundedT = String.format("%.2f" , T)
//    println("Время полета камня до дна обрыва T: $roundedT с")
//}


//import kotlin.math.sqrt
//
//fun main() {
//    // Константа
//    val g = 9.8 // ускорение свободного падения, м/с^2
//
//    // Ввод данных пользователем
//    print("Введите высоту H (в метрах): ")
//    val H = readLine()?.toDoubleOrNull() ?: return
//
//    print("Введите скорость U (в м/с): ")
//    val U = readLine()?.toDoubleOrNull() ?: return
//
//    // Вычисление времени T, за которое бомба достигнет земли
//    val T = sqrt(2 * H / g)
//
//    // Вычисление подлетного расстояния S
//    val S = U * T
//
//    // Вывод результатов
//    println("Время падения бомбы T: %.2f с".format(T))
//    println("Подлетное расстояние S до объекта: %.2f м".format(S))
//}
//import  kotlin.math.sqrt
//
//fun main() {
//    // Константа
//    val g = 9.8 // ускорение свободного падения, м/с^2
//
//    // Основной цикл программы
//    while (true) {
//        // Ввод данных пользователем
//        print("Введите высоту H (в метрах, или 'exit' для выхода): ")
//        val heightInput = readLine()
//        if (heightInput.equals("exit", ignoreCase = true)) break // Проверка на выход
//
//        val H = heightInput?.toDoubleOrNull()
//        if (H == null) {
//            println("Некорректный ввод высоты. Попробуйте еще раз.")
//            continue
//        }
//
//        print("Введите скорость U (в м/с, или 'exit' для выхода): ")
//        val speedInput = readLine()
//        if (speedInput.equals("exit", ignoreCase = true)) break // Проверка на выход
//
//        val U = speedInput?.toDoubleOrNull()
//        if (U == null) {
//            println("Некорректный ввод скорости. Попробуйте еще раз.")
//            continue
//        }
//
//        // Вычисление времени T, за которое бомба достигнет земли
//        val T = sqrt(2 * H / g)
//
//        // Вычисление подлетного расстояния S
//        val S = U * T
//
//        // Вывод результатов
//        println("Время падения бомбы T: %.2f с".format(T))
//        println("Подлетное расстояние S до объекта: %.2f м".format(S))
//        println() // Пустая строка для лучшей читаемости
//    }
//
//    println("Выход из программы.")
//}



//fun main() {
//    // Ввод данных пользователем
//    print("Введите скорость V (в м/с): ")
//    val V = readLine()?.toDoubleOrNull() ?: return
//    print("Введите время t (в секундах): ")
//    val t = readLine()?.toDoubleOrNull() ?: return
//
//    // Вычисление пути S1 (при равномерном движении)
//    val S1 = V * t
//
//    // Вычисление ускорения // (при равнозамедленном движении)
//    val a = V / t
//
//    // Вычисление пути S2 (при равнозамедленном движении)
//    val S2 = (a * t * t) / 2
//
//    // Общий путь S
//    val S = S1 + S2
//
//    // Сравнительный путь S3
//    val S3 = (3 * V * t) / 2
//
//    // Вывод результатов
//    println("Путь S, пройденный поездом: %.2f м".format(S))
//    println("Сравнительный путь S (3Vt / 2): %.2f м".format(S3))
//}

// Константы
//    val G = 6.672e-11 // гравитационная постоянная (м^3/(кг*с^2))
//    val M = 5.96e24 // масса Земли (кг)
//    val R = 6.37e6 // радиус Земли (м)
//
//    // Ввод высоты h
//    print("Введите высоту h над поверхностью Земли (в метрах): ")
//    val h = readLine()?.toDoubleOrNull() ?: return
//
//    // Вычисление ускорения свободного падения g
//    val g = G * M / ((R + h) * (R + h))
//
//    // Вывод результата
//    println("Ускорение свободного падения g на высоте $h м: %.6f м/с²".format(g))
//}
//fun main() {
//    // Исходная строка
//    val phrase = "Kotlin Programming Language"
//    println("Исходная строка: $phrase")
//
//    // Использование substring() с указанием начального и конечного индексов
//    val subPhrase1 = phrase.substring(0, 6)  // Извлекаем подстроку с 0 до 5 индекса
//    println("Подстрока с 0 по 5 индекс: $subPhrase1")
//
//    // Использование substring() с указанием только начального индекса
//    val subPhrase2 = phrase.substring(7)  // Извлекаем подстроку начиная с 7 индекса до конца
//    println("Подстрока с 7 индекса до конца: $subPhrase2")
//
//    // Доступ к символам строки с помощью квадратных скобок []
//    println("Символ на позиции 0: ${phrase[0]}")
//    println("Символ на позиции 7: ${phrase[7]}")
//    println("Последний символ строки: ${phrase[phrase.length - 1]}")
//
//    // Проверка границ при доступе к символам через []
//    if (phrase.length > 25) {
//        println("Символ на позиции 25: ${phrase[25]}")
//    }
//
//    // Работа с индексами строки
//    for (i in 0 until phrase.length step 3) {
//        println("Символ на позиции $i: ${phrase[i]}")
//    }
//
//    // Пример использования substring и обработки пустых строк
//    val emptyString = ""
//    val subEmptyString = emptyString.substring(0.coerceAtMost(emptyString.length)) // Защита от IndexOutOfBoundsException
//    println("Подстрока пустой строки: '$subEmptyString'")
//
//    // Использование substring() с условием для избежания ошибок
//    val safeSubstring = if (phrase.length >= 20) phrase.substring(10, 20) else phrase
//    println("Безопасная подстрока с 10 по 19 индекс (если возможно): $safeSubstring")
//
//    // Работа с символами строки с помощью цикла и квадратных скобок
//    println("Символы строки с шагом в 2:")
//    for (i in 0 until phrase.length step 2) {
//        print("${phrase[i]} ")
//    }
//    println() // Переход на новую строку
//}
//**Метод substring()**:
//- phrase.substring(0, 6) — извлекает подстроку с 0 по 5 индекс. Это символы с начала строки до указанного индекса, не включая его.
//- phrase.substring(7) — извлекает подстроку с 7 индекса до конца строки.
//- Метод substring() используется для извлечения части строки. При этом можно передать либо один аргумент (начальный индекс), либо два (начальный и конечный индексы).
//Оператор доступа к символам строки через [][]**:
//- phrase[0] — получение символа строки по индексу. Это аналог метода charAt из Java.
//- Можно напрямую обращаться к символам строки, используя квадратные скобки и передавая индекс, как это делается в массивах.
//- Доступ к символу строки с использованием индекса последнего элемента: phrase[phrase.length - 1].
//Цикл для работы с индексамими**:
//- Цикл for с шагом в 3 позволяет пропускать символы, выводя символы на позициях 0, 3, 6 и т.д.
//
//4. **Обработка пустых строк с substring()**:
//- Если строка пустая, мы можем избежать ошибки, используя функцию coerceAtMost, чтобы подстраховать границы для метода substring().
//
//5. **Безопасное извлечение подстроки**:
//- Пример с условием: если длина строки позволяет, извлекается подстрока с 10 по 19 индекс, иначе возвращается вся Использование цикла с квадратными скобкамии скобками**:
//- Пример с шагом в 2 — вывод символов строки с пропуском через один.
//
//### Пример работы программы:
//
//#### Вывод:
//
//`
//Исходная строка: Kotlin Programming Language
//Подстрока с 0 по 5 индекс: Kotlin
//Подстрока с 7 индекса до конца: Programming Language
//Символ на позиции 0: K
//Символ на позиции 7: P
//Последний символ строки: e
//Символ на позиции 25: g
//Символ на позиции 0: K
//Символ на позиции 3: l
//Символ на позиции 6:
//Символ на позиции 9: o
//Символ на позиции 12: r
//Символ на позиции 15: m
//Символ на позиции 18: L
//Символ на позиции 21: u
//Символ на позиции 24: g
//Подстрока пустой строки: ''
//Безопасная подстрока с 10 по 19 индекс (если возможно): ogramming
//Символы строки с шагом в 2:
//K t i  P o r m i g L n u g
//`
//
//### Важные моменты:
//- Метод `substring()`: очень полезен для извлечения частей строки. Важно следить за диапазонами индексов, чтобы избежать ошибок.
//- Оператор `[]`: удобен для доступа к символам строки по индексам.
//- Проверка границ: при работе с индексами полезно проверять длину строки, чтобы не возникало ошибок при попытке доступа за пределами строки.
//
//Этот пример теперь включает все запрашиваемые моменты: работу с `substring()`, оператором `[]`, а также показаны примеры безопасного использования этих методов.
//Вот дополненный пример программы, в котором добавлены методы для работы со строками, включая использование метода indexOf:
//
//### Программа на Kotlin с методами работы со строками
//fun main() {
//    // Работа со строками: методы строки
//    val phrase = "Kotlin Programming Language"
//    println("Исходная строка: $phrase")
//
//    // Получение длины строки
//    println("Длина строки: ${phrase.length}")
//
//    // Преобразование строки в заглавные буквы
//    println("Заглавные буквы: ${phrase.uppercase()}")
//
//    // Проверка наличия подстроки
//    println("Строка содержит 'Kotlin'? ${phrase.contains("Kotlin")}")
//
//    // Замена части строки
//    println("Замена 'Kotlin' на 'Java': ${phrase.replace("Kotlin", "Java")}")
//
//    // Получение индекса подстроки
//    val indexOfProgramming = phrase.indexOf("Programming")
//    if (indexOfProgramming != -1) {
//        println("Индекс начала подстроки 'Programming': $indexOfProgramming")
//    } else {
//        println("Подстрока 'Programming' не найдена.")
//    }
//
//    // Извлечение части строки (с помощью substring)
//    val substring = phrase.substring(7, 18)
//    println("Подстрока с 7 по 17 индекс: $substring")
//
//    // Проверка индекса подстроки, если её нет
//    val indexOfSwift = phrase.indexOf("Swift")
//    println("Индекс подстроки 'Swift' (если не найдена, будет -1): $indexOfSwift")
//
//    // Разбиение строки на слова
//    val words = phrase.split(" ")
//    println("Слова в строке:")
//    for (word in words) {
//        println(word)
//    }
//
//    // Работа с символами строки
//    println("Символы строки по индексам:")
//    for (i in phrase.indices) {
//        println("Символ на позиции $i: ${phrase[i]}")
//    }
//}
//
//1. **Метод indexOf**:
//- Используется для поиска индекса начала подстроки в строке.
//- Если подстрока найдена, возвращается индекс её первого символа; если не найдена, возвращается -1.
//- Пример: phrase.indexOf("Programming") возвращает индекс начала подстроки "Programming".
//- Для подстроки, которой нет в строке (например, "Swift"), метод вернет -1.
//
//2. **Метод substring**:
//- Используется для извлечения части строки.
//- В примере: phrase.substring(7, 18) извлекает подстроку с 7 по 17 индекс включительДругие методы работы со строкамироками**:
//- Преобразование строки в заглавные буквы (uppercase()).
//- Проверка наличия подстроки (contains()).
//- Замена части строки (replace()).
//- Разбиение строки на слова (split(" ")).
//- Вывод символов строки по индексам (phrase[i]).
//
//### Пример работы программы:
//
//#### Вывод:
//## Важные моменты:
//- Метод indexOf важен для поиска подстроки в строке, и его использование помогает узнать, на какой позиции начинается искомое слово или фраза.
//- Если подстрока не найдена, возвращается значение -1, что можно обработать условием, чтобы избежать ошибок.
//- Работа с индексами символов строки (через phrase[i] или метод indices) позволяет получить доступ к каждому символу строки.
//Теперь пример демонстрирует более полную работу со строками, включая использование метода indexOf.
//Конечно! Вот дополненный пример программы на Kotlin, в котором используются методы substring и оператор доступа к элементам строки с помощью квадратных скобок [], а также несколько примеров работы с substring() с разными вариантами вызова.
//fun main() {
//    // Исходная строка
//    val phrase = "Kotlin Programming Language"
//    println("Исходная строка: $phrase")
//
//    // Использование substring() с указанием начального и конечного индексов
//    val subPhrase1 = phrase.substring(0, 6)  // Извлекаем подстроку с 0 до 5 индекса
//    println("Подстрока с 0 по 5 индекс: $subPhrase1")
//
//    // Использование substring() с указанием только начального индекса
//    val subPhrase2 = phrase.substring(7)  // Извлекаем подстроку начиная с 7 индекса до конца
//    println("Подстрока с 7 индекса до конца: $subPhrase2")
//
//    // Доступ к символам строки с помощью квадратных скобок []
//    println("Символ на позиции 0: ${phrase[0]}")
//    println("Символ на позиции 7: ${phrase[7]}")
//    println("Последний символ строки: ${phrase[phrase.length - 1]}")
//
//    // Проверка границ при доступе к символам через []
//    if (phrase.length > 25) {
//        println("Символ на позиции 25: ${phrase[25]}")
//    }
//
//    // Работа с индексами строки
//    for (i in 0 until phrase.length step 3) {
//        println("Символ на позиции $i: ${phrase[i]}")
//    }
//
//    // Пример использования substring и обработки пустых строк
//    val emptyString = ""
//    val subEmptyString = emptyString.substring(0.coerceAtMost(emptyString.length)) // Защита от IndexOutOfBoundsException
//    println("Подстрока пустой строки: '$subEmptyString'")
//
//    // Использование substring() с условием для избежания ошибок
//    val safeSubstring = if (phrase.length >= 20) phrase.substring(10, 20) else phrase
//    println("Безопасная подстрока с 10 по 19 индекс (если возможно): $safeSubstring")
//
//    // Работа с символами строки с помощью цикла и квадратных скобок
//    println("Символы строки с шагом в 2:")
//    for (i in 0 until phrase.length step 2) {
//        print("${phrase[i]} ")
//    }
//    println() // Переход на новую строку
//}
//1. **Метод indexOf**:
//- Используется для поиска индекса начала подстроки в строке.
//- Если подстрока найдена, возвращается индекс её первого символа; если не найдена, возвращается -1.
//- Пример: phrase.indexOf("Programming") возвращает индекс начала подстроки "Programming".
//- Для подстроки, которой нет в строке (например, "Swift"), метод вернет -1.
//
//2. **Метод substring**:
//- Используется для извлечения части строки.
//- В примере: phrase.substring(7, 18) извлекает подстроку с 7 по 17 индекс включительДругие методы работы со строкамироками**:
//- Преобразование строки в заглавные буквы (uppercase()).
//- Проверка наличия подстроки (contains()).
//- Замена части строки (replace()).
//- Разбиение строки на слова (split(" ")).
//- Вывод символов строки по индексам (phrase[i]).
//### Важные моменты:
//- Метод indexOf важен для поиска подстроки в строке, и его использование помогает узнать, на какой позиции начинается искомое слово или фраза.
//- Если подстрока не найдена, возвращается значение -1, что можно обработать условием, чтобы избежать ошибок.
//- Работа с индексами символов строки (через phrase[i] или метод indices) позволяет получить доступ к каждому символу строки.
//fun main() {
//    // Условный оператор when с return
//    val grade = 85
//    val result = getGradeResult(grade)
//    println("Результат экзамена: $result")
//
//    // Логические операторы || и &&
//    val age = 20
//    val isStudent = true
//    if (age >= 18 && isStudent) {
//        println("Взрослый студент.")
//    } else if (age < 18 || !isStudent) {
//        println("Несовершеннолетний или не студент.")
//    } else {
//        println("Просто взрослый.")
//    }
//
//    // Тернарный оператор ?:
//    val input: String? = null
//    val processedInput = input ?: "Значение по умолчанию"
//    println("Обработанное значение: $processedInput")
//
//    // Цикл do-while
//    var counter = 0
//    do {
//        println("Счетчик в do-while: $counter")
//        counter++
//    } while (counter < 5)
//
//    // Работа со строками: методы строки
//    val phrase = "Kotlin Programming"
//    println("Длина строки: ${phrase.length}")
//    println("Заглавные буквы: ${phrase.uppercase()}")
//    println("Строка содержит 'Kotlin'? ${phrase.contains("Kotlin")}")
//    println("Замена слова 'Kotlin' на 'Java': ${phrase.replace("Kotlin", "Java")}")
//
//    // Работа со строками: разбиение строки
//    val words = phrase.split(" ")
//    println("Слова в строке:")
//    for (word in words) {
//        println(word)
//    }
//}
//
//// Функция для получения результата экзамена с использованием when
//fun getGradeResult(grade: Int): String {
//    return when (grade) {
//        in 90..100 -> "Отлично"
//        in 75..89 -> "Хорошо"
//        in 50..74 -> "Удовлетворительно"
//        else -> "Неудовлетворительно"
//    }
//}
//. **Условный оператор when с return**:
//- Функция getGradeResult принимает оценку и использует оператор when для возврата результата в зависимости от диапазона оценки.
//- В этом примере диапазоны оценок 90..100, 75..89, и т.д. определяют результат.
//
//2. **Логические операторы || и &&**:
//- Используются для проверки нескольких условий одновременно:
//- age >= 18 && isStudent: проверяет, что человек взрослый и является студентом.
//- age < 18 || !isStudent: проверяет, что человек либо несовершеннолетний, либо не студентТернарный оператор ?:тор ?:**:
//- Это аналог тернарного оператора в других языках. Используется для задания значения по умолчанию, если исходное значение null.
//- В примере: input ?: "Значение по умолчанию" означает, что если input равно null, будет использоваться строка "Значение по умолчанию".
//
//4. **Цикл do-while**:
//- Цикл do-while выполняется хотя бы один раз, даже если условие ложно с самого начала.
//- В примере цикл выполняется до тех пор, пока значение счетчика меРабота со строкамио строками**:
//- Используются разные методы для работы со строками:
//- phrase.length — длина строки.
//- phrase.uppercase() — преобразование строки в заглавные буквы.
//- phrase.contains("Kotlin") — проверка, содержит ли строка подстроку "Kotlin".
//- phrase.replace("Kotlin", "Java") — замена одного слова на Разбиение строкиние строки**:
//- Метод split(" ") разбивает строку на слова по пробелам.
//- Пример цикла for, который выводит каждое слово отдельно.
//
//Этот пример программы демонстрирует использование многих ключевых возможностей Kotlin,
//таких как логические операторы, цикл do-while, работа со строками, использование тернарного оператора ?: и условного оператора when.
//Конечно! Давайте дополню пример с использованием конструкции when, цикла do-while и добавлю больше работы со строками.
//fun main() {
//    // Переменные и типы данных
//    var age: Int = 25 // целое число
//    val name: String = "Иван" // строка (неизменяемая переменная)
//    var salary: Double = 45000.50 // число с плавающей точкой
//    val isStudent: Boolean = false // булево значение
//
//    // Операторы
//    age += 1 // увеличиваем возраст на 1
//    salary *= 1.1 // увеличиваем зарплату на 10%
//
//    // Условные операторы
//    if (age >= 18) {
//        println("$name уже совершеннолетний.")
//    } else {
//        println("$name еще несовершеннолетний.")
//    }
//
//    // when - альтернатива if-else
//    when (salary) {
//        in 50000.0..100000.0 -> println("Высокая зарплата.")
//        in 30000.0..49999.99 -> println("Средняя зарплата.")
//        else -> println("Низкая зарплата.")
//    }
//
//    // Работа со строками: конкатенация и интерполяция
//    val jobTitle: String = "Программист"
//    val fullDescription = "$name, возраст $age, должность: $jobTitle, зарплата: ${"%.2f".format(salary)}"
//    println(fullDescription)
//
//    // Строковые функции
//    val phrase = "Kotlin programming is fun!"
//    println("Длина строки: ${phrase.length}")
//    println("Содержит ли 'fun': ${phrase.contains("fun")}")
//    println("Подстрока с 0 по 6: ${phrase.substring(0, 6)}")
//    println("Все буквы в верхнем регистре: ${phrase.uppercase()}")
//    println("Все буквы в нижнем регистре: ${phrase.lowercase()}")
//
//    // Циклы: цикл for
//    println("Числа от 1 до 5:")
//    for (i in 1..5) {
//        println(i)
//    }
//
//    // Цикл while
//    var counter = 0
//    while (counter < 5) {
//        println("Счетчик: $counter")
//        counter++
//    }
//
//    // Цикл do-while (выполняется хотя бы один раз)
//    var num: Int
//    do {
//        print("Введите положительное число: ")
//        num = readLine()?.toIntOrNull() ?: 0
//        if (num <= 0) {
//            println("Ошибка! Нужно ввести положительное число.")
//        }
//    } while (num <= 0)
//    println("Вы ввели: $num")
//
//    // Работа с пользовательским вводом
//    print("Введите строку для реверса: ")
//    val inputString = readLine() ?: ""
//    val reversedString = inputString.reversed()
//    println("Реверс строки: $reversedString")
//
//    // Цикл для работы с символами строки
//    println("Вывод символов строки:")
//    for (char in inputString) {
//        print("$char ")
//    }
//    println() // Переход на новую строку
//}
//**Конструкция when**:
//- when — это аналог switch в других языках программирования. Она используется для проверки диапазонов значений зарплаты.
//- В примере when используется для проверки диапазона зарплаты и вывода соответствующего сообщения.
//
//2. **Цикл do-while**:
//- Цикл do-while выполняется хотя бы один раз, а затем проверяет условие.
//В примере цикл запрашивает у пользователя положительное число, пока он не введет корректное значенРабота со строкамироками**:
//- Добавлены методы для работы со строками:
//- length: возвращает длину строки.
//- contains: проверяет, содержит ли строка подстроку.
//- substring: возвращает подстроку.
//- uppercase и lowercase: переводят все символы строки в верхний или нижний регистр.
//fun main() {
//    // Переменные и типы данных
//    var age: Int = 25 // целое число
//    val name: String = "Иван" // строка (неизменяемая переменная)
//    var salary: Double = 45000.50 // число с плавающей точкой
//    val isStudent: Boolean = false // булево значение
//
//    // Операторы
//    age += 1 // увеличиваем возраст на 1
//    salary *= 1.1 // увеличиваем зарплату на 10%
//
//    // Условные операторы
//    if (age >= 18) {
//        println("$name уже совершеннолетний.")
//    } else {
//        println("$name еще несовершеннолетний.")
//    }
//
//    // Условные операторы с "else if"
//    if (salary > 50000) {
//        println("Высокая зарплата.")
//    } else if (salary >= 30000) {
//        println("Средняя зарплата.")
//    } else {
//        println("Низкая зарплата.")
//    }
//
//    // Работа со строками: конкатенация и интерполяция
//    val jobTitle: String = "Программист"
//    val fullDescription = "$name, возраст $age, должность: $jobTitle, зарплата: ${"%.2f".format(salary)}"
//    println(fullDescription)
//
//    // Циклы: цикл for
//    println("Числа от 1 до 5:")
//    for (i in 1..5) {
//        println(i)
//    }
//
//    // Цикл while
//    var counter = 0
//    while (counter < 5) {
//        println("Счетчик: $counter")
//        counter++
//    }
//
//    // Работа с пользовательским вводом
//    print("Введите строку для реверса: ")
//    val inputString = readLine() ?: ""
//    val reversedString = inputString.reversed()
//    println("Реверс строки: $reversedString")
//
//    // Цикл для работы с символами строки
//    println("Вывод символов строки:")
//    for (char in inputString) {
//        print("$char ")
//    }
//    println() // Переход на новую строку
//}
//Переменные и типы данных:
//- age — изменяемая переменная типа Int (целое число).
//- name — неизменяемая переменная типа String (строка).
//- salary — изменяемая переменная типа Double (число с плавающей точкой).
//- isStudent — неизменяемая переменная типа Boolean (булево значение).
//
//2. Операторы:
//- Используются арифметические операторы для изменения переменных: +=, *=.
//
//3. Условные операторы:
//- Программа проверяет, совершеннолетний ли человек, используя условие if-else.
//- Используется структура else if для проверки диапазонов зарплаты.
//
//4. Работа со строками:
//- Строки объединяются с помощью интерполяции: "$name, возраст $age".
//- Форматирование чисел с плавающей точкой с помощью format().
//
//5. Циклы:
//- Цикл for используется для вывода чисел от 1 до 5.
//- Цикл while используется для счетчика, который увеличивается до 5.
//
//6. Работа с пользовательским вводом:
//- Программа принимает строку от пользователя и реверсирует её с помощью функции reversed().
//
//7. Цикл для работы с символами строки:
//- Цикл for проходит по каждому символу строки и выводит его по одному.
//fun main() {
//    // Переменные и типы данных
//    var age: Int = 25 // целое число
//    val name: String = "Иван" // строка (неизменяемая переменная)
//    var salary: Double = 45000.50 // число с плавающей точкой
//    val isStudent: Boolean = false // булево значение
//
//    // Операторы
//    age += 1 // увеличиваем возраст на 1
//    salary *= 1.1 // увеличиваем зарплату на 10%
//
//    // Условные операторы
//    if (age >= 18) {
//        println("$name уже совершеннолетний.")
//    } else {
//        println("$name еще несовершеннолетний.")
//    }
//
//    // when - альтернатива if-else
//    when (salary) {
//        in 50000.0..100000.0 -> println("Высокая зарплата.")
//        in 30000.0..49999.99 -> println("Средняя зарплата.")
//        else -> println("Низкая зарплата.")
//    }
//
//    // Работа со строками: конкатенация и интерполяция
//    val jobTitle: String = "Программист"
//    val fullDescription = "$name, возраст $age, должность: $jobTitle, зарплата: ${"%.2f".format(salary)}"
//    println(fullDescription)
//
//    // Строковые функции
//    val phrase = "Kotlin programming is fun!"
//    println("Длина строки: ${phrase.length}")
//    println("Содержит ли 'fun': ${phrase.contains("fun")}")
//    println("Подстрока с 0 по 6: ${phrase.substring(0, 6)}")
//    println("Все буквы в верхнем регистре: ${phrase.uppercase()}")
//    println("Все буквы в нижнем регистре: ${phrase.lowercase()}")
//
//    // Циклы: цикл for
//    println("Числа от 1 до 5:")
//    for (i in 1..5) {
//        println(i)
//    }
//
//    // Цикл while
//    var counter = 0
//    while (counter < 5) {
//        println("Счетчик: $counter")
//        counter++
//    }
//
//    // Цикл do-while (выполняется хотя бы один раз)
//    var num: Int
//    do {
//        print("Введите положительное число: ")
//        num = readLine()?.toIntOrNull() ?: 0
//        if (num <= 0) {
//            println("Ошибка! Нужно ввести положительное число.")
//        }
//    } while (num <= 0)
//    println("Вы ввели: $num")
//
//    // Работа с пользовательским вводом
//    print("Введите строку для реверса: ")
//    val inputString = readLine() ?: ""
//    val reversedString = inputString.reversed()
//    println("Реверс строки: $reversedString")
//
//    // Цикл для работы с символами строки
//    println("Вывод символов строки:")
//    for (char in inputString) {
//        print("$char ")
//    }
//    println() // Переход на новую строку
//}
//**Конструкция when**:
//- when — это аналог switch в других языках программирования. Она используется для проверки диапазонов значений зарплаты.
//- В примере when используется для проверки диапазона зарплаты и вывода соответствующего сообщения.
//
//2. **Цикл do-while**:
//- Цикл do-while выполняется хотя бы один раз, а затем проверяет условие.
//В примере цикл запрашивает у пользователя положительное число, пока он не введет корректное значенРабота со строкамироками**:
//- Добавлены методы для работы со строками:
//- length: возвращает длину строки.
//- contains: проверяет, содержит ли строка подстроку.
//- substring: возвращает подстроку.
//- uppercase и lowercase: переводят все символы строки в верхний или нижний регистр.
//fun main() {
//    val numbers = listOf(1, 2, 3, 4, 5, 6, 7)
//    val result = numbers.joinToString(separator = ", ", limit = 4, truncated = "...и еще")
//    println(result)
//}
//joinToString — это функция в Kotlin, которая используется для объединения элементов коллекции (например, списка или массива) в строку с помощью заданного разделителя. Она позволяет настроить не только разделитель, но и формат вывода каждого элемента, а также добавить префикс и суффикс к итоговой строке.
//
//### Основные параметры joinToString:
//1. separator — разделитель, который будет добавлен между элементами. По умолчанию это запятая (,).
//2. prefix — строка, которая будет добавлена в начало результирующей строки.
//3. postfix — строка, которая будет добавлена в конец результирующей строки.
//4. limit — ограничение на количество элементов, которые будут включены в строку. Остальные заменяются символами ....
//5. truncated — строка, которая будет добавлена, если число элементов превышает значение limit (по умолчанию ...).
//6. transform — лямбда-функция, которая используется для преобразования каждого элемента коллекции перед объединением.
//
//### Пример использования joinToString
//
//#### Пример 1: Простой пример
//
//
//fun main() {
//    val numbers = listOf(1, 2, 3, 4, 5)
//    val result = numbers.joinToString(separator = ", ", prefix = "[", postfix = "]")
//    println(result)
//}
//Вывод:
//копировать
//
//[1, 2, 3, 4, 5]
//Здесь:
//- separator — запятая с пробелом ,  используется как разделитель между элементами.
//- prefix — добавлен в начале строки ([).
//- postfix — добавлен в конце строки (]).
//
//#### Пример 2: Использование limit и truncated
//
//
//fun main() {
//    val numbers = listOf(1, 2, 3, 4, 5, 6, 7)
//    val result = numbers.joinToString(separator = ", ", limit = 4, truncated = "...и еще")
//    println(result)
//}
//Вывод:
//копировать
//
//1, 2, 3, 4...и еще
//Здесь:
//- limit — выводит только первые 4 элемента.
//- truncated — заменяет оставшиеся элементы строкой ...и еще.
//
//#### Пример 3: Преобразование элементов с помощью transform
//
//
//fun main() {
//    val words = listOf("apple", "banana", "cherry")
//    val result = words.joinToString(separator = " | ") { it.uppercase() }
//    println(result)
//}
//Вывод:
//копировать
//
//APPLE | BANANA | CHERRY
//Здесь:
//- Используется лямбда-функция, которая преобразует каждый элемент в верхний регистр перед объединением.
//
//#### Пример 4: Объединение массива
//Kotl
//
//fun main() {
//    val chars = arrayOf('A', 'B', 'C', 'D')
//    val result = chars.joinToString(separator = "-")
//    println(result)
//}
//Вывод:
//копировать
//
//A-B-C-D
//Здесь:
//- Элементы массива символов объединяются через дефис -.
//
//### Использование по умолчанию
//Если вызвать joinToString без указания параметров, результат будет объединен через запятую:
//
//
//fun main() {
//    val numbers = listOf(1, 2, 3)
//    println(numbers.joinToString())  // Использование по умолчанию
//}
//Вывод:
//копировать
//
//1, 2, 3
//### Заключение:
//joinToString — это очень мощная и гибкая функция для работы с коллекциями и их преобразованием в строку.
//Она удобна для форматирования вывода коллекций в текстовом формате, будь то простой список элементов или сложные структуры с кастомными разделителями и ограничениями.
//fun main() {
//    val a = 5
//    val b = 3
//
//    // Арифметические операторы
//    println("Сложение: ${a + b}")   // 8
//    println("Вычитание: ${a - b}")  // 2
//    println("Умножение: ${a * b}")  // 15
//    println("Деление: ${a / b}")    // 1
//    println("Остаток: ${a % b}")    // 2
//
//    // Операторы сравнения
//    println(a > b)  // true
//    println(a < b)  // false
//    println(a == b) // false
//    println(a != b) // true
//
//    // Логические операторы
//    val isTrue = a > b && a != b
//    println(isTrue) // true
//}
//fun main() {
//    val age = 18
//
//    if (age >= 18) {
//        println("Вы совершеннолетний")
//    } else {
//        println("Вы несовершеннолетний")
//    }
//
//    // Оператор when
//    val day = 2
//    val dayName = when (day) {
//        1 -> "Понедельник"
//        2 -> "Вторник"
//        3 -> "Среда"
//        else -> "Неизвестный день"
//    }
//    println(dayName)  // Вторник
//}
//fun main() {
//    // Цикл for
//    for (i in 1..5) {
//        println("Цикл for: $i")
//    }
//
//    // Цикл while
//    var x = 1
//    while (x <= 5) {
//        println("Цикл while: $x")
//        x++
//    }
//
//    // Цикл do-while
//    var y = 1
//    do {
//        println("Цикл do-while: $y")
//        y++
//    } while (y <= 5)
//}
//fun main() {
//    val phrase = "Hello, Kotlin!"
//
//    // Доступ к символам
//    println(phrase[0]) // H
//
//    // Длина строки
//    println(phrase.length) // 13
//
//    // Поиск подстроки
//    val index = phrase.indexOf("Kotlin")
//    println(index)  // 7
//
//    // Извлечение подстроки
//    val sub = phrase.substring(7, 13)
//    println(sub)  // Kotlin
//}
//fun main() {
//    val name = "Kotlin"
//    val version = 1.5
//
//    // Форматирование через шаблоны
//    val message = "Добро пожаловать в $name версии $version!"
//    println(message)
//
//    // Использование String.format
//    val formatted = String.format("Версия: %.1f", version)
//    println(formatted)  // Версия: 1.5
//}
//fun main() {
//    val word1 = "Hello"
//    val word2 = "Kotlin"
//
//    // Конкатенация строк
//    val greeting = word1 + ", " + word2 + "!"
//    println(greeting)  // Hello, Kotlin!
//
//    // joinToString для списков
//    val numbers = listOf(1, 2, 3, 4, 5)
//    val joined = numbers.joinToString(separator = " - ")
//    println(joined)  // 1 - 2 - 3 - 4 - 5
//}
//fun main() {
//    val name = "Kotlin"
//    val version = 1.5
//
//    // Форматирование через шаблоны
//    val message = "Добро пожаловать в $name версии $version!"
//    println(message)
//
//    // Использование String.format
//    val formatted = String.format("Версия: %.1f", version)
//    println(formatted)  // Версия: 1.5
//}
//### 6. Перезагрузка строк (concat, joinToString)
//Конкатенация строк и объединение коллекций в строки.
//
//
//
//fun main() {
//    val word1 = "Hello"
//    val word2 = "Kotlin"
//
//    // Конкатенация строк
//    val greeting = word1 + ", " + word2 + "!"
//    println(greeting)  // Hello, Kotlin!
//
//    // joinToString для списков
//    val numbers = listOf(1, 2, 3, 4, 5)
//    val joined = numbers.joinToString(separator = " - ")
//    println(joined)  // 1 - 2 - 3 - 4 - 5
//}
//### Итог:
//На начальном уровне студент, изучивший эти темы, может оперировать кодом, содержащим около 50-100 строк для примеров и задач.
//
//Темы охвачены базовыми примерами на:
//- арифметические и логические операторы,
//- условные операторы (if и when),
//- циклы (for, while, do-while),
//- работу со строками (substring, indexOf),
//- форматирование строк,
//- и работу с коллекциями (joinToString).
//
//Это поможет лучше понять основы языка Kotlin.
//Вот примеры задач на каждую тему, включая условные операторы, циклы и работу со строками. Каждая задача имеет комментарии и пояснения.
//
//### 1. Операторы
//
//Задача 1: Арифметические операции
//
//
//fun main() {
//    val a = 10
//    val b = 5
//
//    // Сложение
//    println("Сложение: ${a + b}")  // 15
//
//    // Вычитание
//    println("Вычитание: ${a - b}") // 5
//
//    // Умножение
//    println("Умножение: ${a * b}") // 50
//
//    // Деление
//    println("Деление: ${a / b}")   // 2
//}
//Задача 2: Логические операторы
//
//
//fun main() {
//    val x = true
//    val y = false
//
//    // Логическое И
//    println("x && y = ${x && y}") // false
//
//    // Логическое ИЛИ
//    println("x || y = ${x || y}") // true
//
//    // Логическое НЕ
//    println("!x = ${!x}")         // false
//}
//### 2. Условные операторы
//
//**Задача 3: Условие if**
//
//
//fun main() {
//    val number = 10
//
//    if (number % 2 == 0) {
//        println("$number - четное число")
//    } else {
//        println("$number - нечетное число")
//    }
//}
//**Задача 4: Условие when**
//
//fun main() {
//    val day = 3
//
//    // Проверка дня недели
//    val dayName = when (day) {
//        1 -> "Понедельник"
//        2 -> "Вторник"
//        3 -> "Среда"
//        4 -> "Четверг"
//        5 -> "Пятница"
//        6 -> "Суббота"
//        7 -> "Воскресенье"
//        else -> "Неизвестный день"
//    }
//    println(dayName) // Среда
//}
//### 3.Задача 5: Цикл forкл for**
//
//
//fun main() {
//    // Вывод чисел от 1 до 5
//    for (i in 1..5) {
//        println("Число: $i")
//    }
//}
//**Задача 6: Цикл while**
//
//
//fun main() {
//    var count = 1
//    while (count <= 5) {
//        println("Счетчик: $count")
//        count++ // Увеличиваем счетчик
//    }
//}
//**Задача 7: Цикл do-while**
//
//
//fun main() {
//    var num = 1
//    do {
//        println("Число: $num")
//        num++
//    } while (num <= 5)
//}
//**Задача 8: Вложенные циклы**
//
//
//fun main() {
//    for (i in 1..3) {
//        for (j in 1..3) {
//            println("i = $i, j = $j")
//        }
//    }
//}
//### 4. Задача 9: Индексирование строкиексирование строки**
//
//
//fun main() {
//    val phrase = "Kotlin"
//
//    // Доступ к символу по индексу
//    println("Первый символ: ${phrase[0]}") // K
//    println("Третий символ: ${phrase[2]}") // t
//}
//**Задача 10: Использование substring()**
//
//
//fun main() {
//    val text = "Hello, Kotlin!"
//
//    // Извлечение подстроки
//    val subText = text.substring(7, 13)
//    println("Подстрока: $subText") // Kotlin
//}
//**Задача 11: Поиск подстроки с indexOf()**
//
//
//fun main() {
//    val sentence = "Learning Kotlin is fun!"
//    val index = sentence.indexOf("Kotlin")
//
//    if (index != -1) {
//        println("Kotlin найден на индексе: $index")
//    } else {
//        println("Kotlin не найден")
//    }
//}
//**Задача 12: Сравнение строк**
//
//
//fun main() {
//    val str1 = "Kotlin"
//    val str2 = "Kotlin"
//    val str3 = "Java"
//
//    // Сравнение строк
//    if (str1 == str2) {
//        println("$str1 и $str2 равны")
//    } else {
//        println("$str1 и $str2 не равны")
//    }
//
//    if (str1 != str3) {
//        println("$str1 и $str3 не равны")
//    }
//}
//### 5. Форматирование строк
//
//**Задача 13: Форматирование с использованием шаблонов**
//
//
//fun main() {
//    val name = "Kotlin"
//    val version = 1.5
//
//    // Использование шаблона
//    val message = "Язык программирования: $name, версия: $version"
//    println(message)
//}
//**Задача 14: Форматирование с String.format()**
//
//
//fun main() {
//    val pi = 3.14159
//    val formattedPi = String.format("Значение π: %.2f", pi)
//    println(formattedPi) // Значение π: 3.14
//}
//### 6. Перезагрузка строк
//
//**Задача 15: Использование joinToString()**
//Kotlin
//
//fun main() {
//    val numbers = listOf(1, 2, 3, 4, 5)
//
//    // Объединение чисел в строку
//    val joinedNumbers = numbers.joinToString(separator = ", ", prefix = "[", postfix = "]")
//    println("Числа: $joinedNumbers") // Числа: [1, 2, 3, 4, 5]
//}
//15. Проверка на диапазон значений (продолжение)
//
//
//
//fun main() {
//    val temperature = 25
//    when (temperature) {
//        in -30..0 -> println("Очень холодно")
//        in 1..20 -> println("Прохладно")
//        in 21..35 -> println("Тепло")
//        else -> println("Жарко")
//    }
//}
//
//---
//
//### Циклы (15 примеров)
//
//1. **Цикл for по диапазону**
//
//
//fun main() {
//    for (i in 1..5) {
//        println(i) // Выводит числа от 1 до 5
//    }
//}
//
//2. **Цикл for с шагом**
//fun main() {
//    for (i in 1..10 step 2) {
//        println(i) // Выводит 1, 3, 5, 7, 9
//    }
//}
//
//3. **Цикл for с обратным порядком**
//
//fun main() {
//    for (i in 5 downTo 1) {
//        println(i) // Выводит 5, 4, 3, 2, 1
//    }
//}
//
//4. **Цикл for по элементам списка**
//
//fun main() {
//    val fruits = listOf("Apple", "Banana", "Cherry")
//    for (fruit in fruits) {
//        println(fruit) // Выводит каждый фрукт
//    }
//}
//
//5. **Цикл while**
//
//
//fun main() {
//    var count = 0
//    while (count < 5) {
//        println(count)
//        count++ // Увеличиваем счетчик
//    }
//}
//
//6. **Цикл do-while**
//
//fun main() {
//    var count = 0
//    do {
//        println(count)
//        count++
//    } while (count < 5) // Выводит 0, 1, 2, 3, 4
//}
//
//7. **Использование break для выхода из цикла**
//
//fun main() {
//    for (i in 1..10) {
//        if (i == 5) break // Прерываем цикл, когда i равно 5
//        println(i) // Выводит 1, 2, 3, 4
//    }
//}
//
//8. **Использование continue для пропуска итерации**
//fun main() {
//    for (i in 1..10) {
//        if (i % 2 == 0) continue // Пропускаем четные числа
//        println(i) // Выводит 1, 3, 5, 7, 9
//    }
//}
//
//9. **Цикл forEach для списков**
//
//fun main() {
//    val numbers = listOf(1, 2, 3, 4, 5)
//    numbers.forEach { number ->
//        println(number) // Выводит каждый элемент списка
//    }
//}
//
//10. **Цикл по индексам списка**
//
//fun main() {
//    val fruits = listOf("Apple", "Banana", "Cherry")
//    for (index in fruits.indices) {
//        println("Фрукт на индексе $index: ${fruits[index]}")
//    }
//}
//
//11. **Двойной цикл для двумерного массива**
//
//fun main() {
//    val matrix = arrayOf(
//        arrayOf(1, 2, 3),
//        arrayOf(4, 5, 6),
//        arrayOf(7, 8, 9)
//    )
//    for (row in matrix) {
//        for (value in row) {
//            print("$value ") // Выводит значения матрицы
//        }
//        println()
//    }
//}
//
//12. **Использование repeat для повторения кода**
//
//fun main() {
//    repeat(3) {
//        println("Привет!") // Выводит "Привет!" 3 раза
//    }
//}
//
//13. **Цикл по символам строки**
//
//fun main() {
//    val str = "Hello"
//    for (char in str) {
//        println(char) // Выводит каждый символ
//    }
//}
//
//14. **Цикл с условием выхода**
//
//fun main() {
//    var sum = 0
//    for (i in 1..100) {
//        sum += i
//        if (sum > 500) break // Прерываем, если сумма больше 500
//    }
//    println("Сумма: $sum")
//}
//
//15. **Цикл с использованием while для подсчета**
//
//fun main() {
//    var count = 0
//    while (count < 10) {
//        println("Текущий счетчик: $count")
//        count++
//    }
//}
//
//-
//
//1. **Создание строки**
//
//
//fun main() {
//    val greeting = "Hello, World!"
//    println(greeting)
//}
//2. Доступ к символу строки по индексу
//
//
//fun main() {
//    val str = "Kotlin"
//    println(str[0]) // K
//}
//
//3. **Изменение строки с использованием substring**
//
//fun main() {
//    val str = "Hello, World!"
//    println(str.substring(0, 5)) // Hello
//}
//
//Проверка длины строкики**
//
//
//fun main() {
//    val str = "Kotlin"
//    println("Длина строки: ${str.length}") // 6
//}
//
//Проверка на наличие подстрокики**
//
//fun main() {
//    val str = "Hello, Kotlin"
//    println(str.contains("Kotlin")) // true
//}
//
//Преобразование строки в верхний регистртр**
//
//fun main() {
//    val str = "kotlin"
//    println(str.uppercase()) // KOTLIN
//}
//
//Преобразование строки в нижний регистртр**
//
//fun main() {
//    val str = "KOTLIN"
//    println(str.lowercase()) // kotlin
//}
//
//Замена подстрокики**
//
//fun main() {
//    val str = "Hello, World!"
//    println(str.replace("World", "Kotlin")) // Hello, Kotlin!
//}
//
//Разделение строки на частити**
//
//fun main() {
//    val str = "Kotlin,Java,Python"
//    val languages = str.split(",")
//    println(languages) // [Kotlin, Java, Python]
//}
//
//Объединение строкок**
//
//fun main() {
//    val firstName = "John"
//    val lastName = "Doe"
//    println("Полное имя: $firstName $lastName") // John Doe
//}
//
//11. **Индексация с помощью indexOf**
//
//
//fun main() {
//    val str = "Hello, Kotlin"
//    println(str.indexOf("Kotlin")) // 7
//}
//
//12. **Удаление пробелов**
//
//
//fun main() {
//    val str = "   Kotlin   "
//    println(str.trim()) // Kotlin
//}
//
//13. **Проверка строки на пустоту**
//
//
//
//fun main() {
//    val str = ""
//    println(str.isEmpty()) // true
//}
//
//14. **Проверка строки на равенство (case-sensitive)**
//
//
//
//fun main() {
//    val str1 = "Kotlin"
//    val str2 = "kotlin"
//    println(str1 == str2) // false
//}
//
//15. **Проверка строки на равенство (case-insensitive)**
//
//
//fun main() {
//    val str1 = "Kotlin"
//    val str2 = "kotlin"
//    println(str1.equals(str2, ignoreCase = true)) // true
//}
//fun main(){
//    print("Рссстояние из А в Б (S)")
//    val s : Double = readLine() ?.toDoubleOrNull()?: return
//    print("Введите Скрость (V)")
//    val v : Double = readLine()?.toDoubleOrNull()?: return
//    print("Время движения (t)")
//    val t : Double = readLine()?.toDoubleOrNull()?: return
//    val v1 : Double = s/t
//    val v2 : Double = s/ (2 * s / v - t )
//    println("средняя скорость : %.2f".format(v1) )
//    println("скорость обратно : %.2f".format(v2))
//}
//for используется для итерирования по коллекциям, диапазонам (ranges), массивам или другим итерабельным объектам.
/*for (item in collection) {
    // действия с элементом item
}
val numbers = listOf(1, 2, 3, 4, 5)
for (number in numbers) {
    println(number)
}
for (i in 1..5) {
    println(i)  // Выведет числа от 1 до 5
}Когда использовать:**
- Когда нужно перебрать элементы коллекции или диапазона.
- Когда заранее известно количество итераций.
while выполняет блок кода, пока условие истинно. Условие проверяется перед каждой итерацией.
while (condition) {
    // действия, пока condition истинно
}
var i = 0
while (i < 5) {
    println(i)
    i++
}
Когда использовать:**
- Когда количество итераций заранее не известно.
- Когда выполнение цикла зависит от некоторого внешнего условия, которое может измениться во время работы программ do-while-цикл*do-while-цикл**
do-while похож на while, но с одним ключевым отличием: условие послеряется **после** выполнения тела цикла, что гарантирует, что код в теле цикла выполнится хотя бы один раз.
do {
    // действия
} while (condition)


var i = 0
do {
    println(i)
    i++
} while (i < 5)
Когда нужно выполнить хотя бы одну итерацию цикла, даже если условие в дальнейшем окажется ложным.

---

for различия:
- **for** используется для итерирования по известным диапазонаwhileлекциям.
- **while** проверяет условие перед каждой итерацией и может ни разу не выполнить тело цикла, если условие иdo-whileжное.
- **do-while** выполняет тело цикла хотя бы один раз, даже если условие изначально ложное.

### Когда какой цикл луforользовать:
- **for** — для работы с диапазонами, коллекциями и массивами, когда количество итераций while известно заранее.
- **while** — когда условие выполнения цикла зависит от внешних факторов, и количество итераций заdo-whileстно.
- **do-while** — когда нужно гарантировать хотя бы одну итерацию, например, при запросе ввода от пользователя до тех пор, пока не введено корректное значение.

 */
//fun findIndexOfFive(arr: IntArray): Int {
//    for (i in arr.indices) {
//        if (arr[i] == 5) return i
//    }
//    return -1 // Если элемент не найден, возвращаем -1
//}
//
//// Использование функции
//val array8 = intArrayOf(2, 4, 5, 6, 8)
//val index = findIndexOfFive(array8)
//println(index)